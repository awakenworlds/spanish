const quizData = [
    {"devanagari":"à¥§","roman":"ek","english":"one","sort":"number"},
    {"devanagari":"à¥¯à¥©","roman":"tiranabbe","english":"ninety-three","sort":"number"},
    {"devanagari":"à¥¯à¥ª","roman":"churanabbe","english":"ninety-four","sort":"number"},
    {"devanagari":"à¥¯à¥«","roman":"pachanabbe","english":"ninety-five","sort":"number"},
    {"devanagari":"à¥§à¥¦à¥¦","roman":"saya","english":"one hundred","sort":"number"},
    {"devanagari":"à¤…","roman":"a","english":"a","sort":"letter"},
    {"devanagari":"à¤†","roman":"aa","english":"aa","sort":"letter"},
    {"devanagari":"à¤µ","roman":"wa","english":"wa","sort":"letter"},
    {"devanagari":"à¤¶","roman":"sha","english":"sha","sort":"letter"},
    {"devanagari":"à¤œà¤¾à¤¨à¥","roman":"janu","english":"to go","sort":"verb","popular":true},
    {"devanagari":"à¤—à¤°à¥à¤¨à¥","roman":"garnu","english":"to do","sort":"verb","popular":true},
    {"devanagari":"à¤šà¤²à¥à¤¨à¥","roman":"chalnu","english":"to walk/move","sort":"verb"},
    {"devanagari":"à¤®à¤¾à¤¨à¥à¤›à¥‡","roman":"manchhe","english":"person","sort":"noun"},
    {"devanagari":"à¤˜à¤°","roman":"ghar","english":"house","sort":"noun","popular":true},
    {"devanagari":"à¤—à¥€à¤¤","roman":"git","english":"song","sort":"noun"},
    {"devanagari":"à¤•à¤¾à¤²à¥‹","roman":"kalo","english":"black","sort":"adjective"},
    {"devanagari":"à¤°à¤¾à¤¤à¥‹","roman":"rato","english":"red","sort":"adjective"},
    {"devanagari":"à¤¬à¥ˆà¤œà¤¨à¥€","roman":"baijani","english":"purple","sort":"adjective"},
    {"devanagari":"à¤¤à¤²","roman":"tala","english":"down/below","sort":"adverb"},
    {"devanagari":"à¤°à¤¾à¤®à¥à¤°à¥‹","roman":"ramro","english":"well","sort":"adverb"},
    {"devanagari":"à¤œà¤¤à¤¿","roman":"jati","english":"as much as","sort":"conjunction"},
    {"devanagari":"à¤°","roman":"ra","english":"and","sort":"conjunction"},
    {"devanagari":"à¤¯à¤¾","roman":"ya","english":"or","sort":"conjunction"},
    {"devanagari":"à¤¤à¤²","roman":"tala","english":"under","sort":"preposition"}
];





const questionEl = document.getElementById('question');
const answerEl = document.getElementById('answer');
const romanizedInput = document.getElementById('romanized-answer-input');
const englishInput = document.getElementById('english-answer-input');
const submitRomanizedBtn = document.getElementById('submit-romanized-btn');
const submitEnglishBtn = document.getElementById('submit-english-btn');
const feedbackEl = document.getElementById('feedback');
const prevBtn = document.getElementById('prev-card-btn');
const showAnswerBtn = document.getElementById('show-answer-btn');
const resetBtn = document.getElementById('reset-btn');
const nextBtn = document.getElementById('next-card-btn');
const categorySelect = document.getElementById('category-select');
const englishFieldGroup = document.getElementById('english-field-group');
const englishModeBtn = document.getElementById('english-mode-btn');

let currentCardIndex = 0;
let filteredQuizData = [];
let isRomanCorrect = false;
let isEnglishCorrect = false;
let isEnglishMode = false;

function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

function displayCard() {
    if (filteredQuizData.length === 0) {
        questionEl.textContent = 'Oops! No flashcards found for this category. Please choose a different one.';
        answerEl.textContent = '';
        answerEl.classList.add('hidden');
        romanizedInput.value = '';
        englishInput.value = '';
        englishFieldGroup.style.display = 'none';
        return;
    }

    const currentCard = filteredQuizData[currentCardIndex];
    answerEl.classList.add('hidden');
    feedbackEl.textContent = '';
    romanizedInput.value = '';
    englishInput.value = '';
    
    // Clear all feedback-related classes for a fresh start
    feedbackEl.classList.remove('correct', 'both-correct', 'incorrect');

    if (isEnglishMode) {
        // In English mode, show English word and ask for Romanized answer
        questionEl.textContent = currentCard.english;
        questionEl.classList.add('english-mode-text');
        englishFieldGroup.style.display = 'none'; // Hide the English input field
        romanizedInput.placeholder = "Enter Romanized Answer";
        englishModeBtn.textContent = 'Toggle to Nepali'; // Update button text
    } else {
        // In Nepali mode, show Devanagari word and ask for both answers
        questionEl.textContent = currentCard.devanagari;
        questionEl.classList.remove('english-mode-text');
        const isSingleAnswer = currentCard.roman.toLowerCase().trim() === currentCard.english.toLowerCase().trim();
        if (isSingleAnswer) {
            englishFieldGroup.style.display = 'none';
            romanizedInput.placeholder = "Enter the answer";
        } else {
            englishFieldGroup.style.display = 'flex';
            romanizedInput.placeholder = "Romanized Answer";
        }
        englishModeBtn.textContent = 'Toggle to English'; // Update button text
    }

    isRomanCorrect = false;
    isEnglishCorrect = false;
    romanizedInput.focus();
}

function checkRomanizedAnswer() {
    const userAnswer = romanizedInput.value.toLowerCase().trim();
    const currentCard = filteredQuizData[currentCardIndex];
    const correctAnswer = currentCard.roman.toLowerCase().trim();
    const isSingleAnswer = currentCard.roman.toLowerCase().trim() === currentCard.english.toLowerCase().trim();

    let kChSwappedUserAnswer = '';
    if (userAnswer.includes('ch')) {
        kChSwappedUserAnswer = userAnswer.replace(/ch/g, 'k');
    } else if (userAnswer.includes('k')) {
        kChSwappedUserAnswer = userAnswer.replace(/k/g, 'ch');
    }

    const isCorrect = (
        userAnswer === correctAnswer ||
        (kChSwappedUserAnswer && kChSwappedUserAnswer === correctAnswer) ||
        userAnswer.replace(/h/g, '') === correctAnswer.replace(/h/g, '') ||
        (kChSwappedUserAnswer && kChSwappedUserAnswer.replace(/h/g, '') === correctAnswer.replace(/h/g, ''))
    );
    
    // Clear previous feedback classes
    feedbackEl.classList.remove('correct', 'both-correct', 'incorrect');

    if (isCorrect) {
        isRomanCorrect = true;
        answerEl.classList.remove('hidden');

        if (isEnglishMode || isSingleAnswer || isEnglishCorrect) {
            // Both answers are correct, or it's a single-answer mode (e.g., in English mode or single field)
            feedbackEl.classList.add('both-correct'); // Dark green
            answerEl.textContent = `${currentCard.roman} ${isEnglishMode ? '' : `| ${currentCard.english}`}`;
            feedbackEl.textContent = "Correct! Great job! ðŸŽ‰ Press 'Next' or 'Enter' to continue.";
        } else {
            // Only Romanized is correct, English is pending
            feedbackEl.classList.add('correct'); // Dark yellow
            answerEl.textContent = `${currentCard.roman}`;
            feedbackEl.textContent = "Correct! Now, please enter the English translation.";
            englishInput.focus();
        }
    } else {
        isRomanCorrect = false;
        feedbackEl.classList.add('incorrect'); // Red
        feedbackEl.textContent = "Not quite. Please try again.";
        answerEl.classList.add('hidden');
    }
}

function checkEnglishAnswer() {
    const userAnswer = englishInput.value.toLowerCase().trim();
    const currentCard = filteredQuizData[currentCardIndex];
    
    const rawEnglish = currentCard.english.toLowerCase().trim();
    const noBrackets = rawEnglish.replace(/\s*\(.*\)/, '');
    const acceptableAnswers = noBrackets.split('/').map(ans => ans.trim());
    
    const isCorrect = acceptableAnswers.includes(userAnswer);

    // Clear previous feedback classes
    feedbackEl.classList.remove('correct', 'both-correct', 'incorrect');

    if (isCorrect) {
        isEnglishCorrect = true;
        answerEl.classList.remove('hidden');

        if (isRomanCorrect) {
            // Both answers are correct
            feedbackEl.classList.add('both-correct'); // Dark green
            answerEl.textContent = `${currentCard.roman} | ${currentCard.english}`;
            feedbackEl.textContent = "Fantastic! Both answers are spot-on! ðŸŽ‰ Press 'Next' or 'Enter' to continue.";
        } else {
            // Only English is correct, Romanized is pending
            feedbackEl.classList.add('correct'); // Dark yellow
            answerEl.textContent = `${currentCard.english}`;
            feedbackEl.textContent = "Correct! Now, what about the Romanized spelling?";
        }
    } else {
        isEnglishCorrect = false;
        feedbackEl.classList.add('incorrect'); // Red
        feedbackEl.textContent = "That's not the correct English translation. Give it another shot!";
        answerEl.classList.add('hidden');
    }
}

function advanceQuiz() {
    nextBtn.click();
}

function showFullAnswer() {
    const currentCard = filteredQuizData[currentCardIndex];
    answerEl.classList.remove('hidden');
    // Ensure only 'correct' class is applied for 'show answer'
    feedbackEl.classList.remove('incorrect', 'both-correct');
    feedbackEl.classList.add('correct'); // Dark yellow for showing the answer
    
    if (isEnglishMode) {
        answerEl.textContent = `${currentCard.roman}`;
    } else {
        answerEl.textContent = `${currentCard.roman} | ${currentCard.english}`;
    }
    feedbackEl.textContent = 'Here is the correct answer. Press "Next" to continue.';
}

submitRomanizedBtn.addEventListener('click', checkRomanizedAnswer);
submitEnglishBtn.addEventListener('click', checkEnglishAnswer);

englishModeBtn.addEventListener('click', () => {
    isEnglishMode = !isEnglishMode;
    applyFilterAndLoad(); // Re-apply the filter when the mode changes
});

romanizedInput.addEventListener('keypress', (event) => {
    if (event.key === 'Enter') {
        const currentCard = filteredQuizData[currentCardIndex];
        const isSingleAnswer = currentCard.roman.toLowerCase().trim() === currentCard.english.toLowerCase().trim();
        
        if ((isEnglishMode && isRomanCorrect) || (!isEnglishMode && isRomanCorrect && isEnglishCorrect) || (!isEnglishMode && isRomanCorrect && isSingleAnswer)) {
            advanceQuiz();
        } else {
            checkRomanizedAnswer();
        }
    }
});

englishInput.addEventListener('keypress', (event) => {
    if (event.key === 'Enter') {
        if (isRomanCorrect && isEnglishCorrect) {
            advanceQuiz();
        } else {
            checkEnglishAnswer();
        }
    }
});

document.addEventListener('keydown', (event) => {
    if (event.key === 'ArrowUp') {
        showFullAnswer();
    }
    // Remove the ArrowRight functionality
    // if (event.key === 'ArrowRight') {
    //     nextBtn.click();
    // }
    if (event.key === 'ArrowLeft') {
        prevBtn.click();
    }
});

nextBtn.addEventListener('click', () => {
    currentCardIndex = (currentCardIndex + 1) % filteredQuizData.length;
    displayCard();
});

prevBtn.addEventListener('click', () => {
    currentCardIndex = (currentCardIndex - 1 + filteredQuizData.length) % filteredQuizData.length;
    displayCard();
});

showAnswerBtn.addEventListener('click', showFullAnswer);

resetBtn.addEventListener('click', () => {
    shuffle(filteredQuizData);
    currentCardIndex = 0;
    displayCard();
});

categorySelect.addEventListener('change', applyFilterAndLoad);

function applyFilterAndLoad() {
    const selectedCategory = categorySelect.value;
    let tempQuizData;

    if (selectedCategory === 'all') {
        tempQuizData = [...quizData];
    } else if (selectedCategory === 'popular') {
        tempQuizData = quizData.filter(card => card.popular === true);
    } else {
        tempQuizData = quizData.filter(card => card.sort === selectedCategory);
    }

    // New filter to omit cards where Roman and English are the same in English mode
    if (isEnglishMode) {
        filteredQuizData = tempQuizData.filter(card => card.roman.toLowerCase().trim() !== card.english.toLowerCase().trim());
    } else {
        filteredQuizData = tempQuizData;
    }
    
    shuffle(filteredQuizData);
    currentCardIndex = 0;
    displayCard();
}

applyFilterAndLoad();
